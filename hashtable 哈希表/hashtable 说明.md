<!-- TOC -->

- [hash表的使用说明](#hash表的使用说明)
    - [hash表的思想](#hash表的思想)
        - [参考链接](#参考链接)
        - [概念](#概念)
        - [要素1: 关键字](#要素1-关键字)
        - [要素2: 散列表](#要素2-散列表)
        - [要素3: 散列函数](#要素3-散列函数)
    - [hash_demo.c 的例子](#hash_democ-的例子)
    - [squid里面的hash实现](#squid里面的hash实现)
        - [squid做的优化](#squid做的优化)

<!-- /TOC -->

# hash表的使用说明

## hash表的思想

###　参考链接

- [百度百科](https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/5981869?fr=aladdin)
- [总结：哈希表（散列表）原理详解](https://blog.csdn.net/duan19920101/article/details/51579136)

### 概念

Hash table，又称散列表，哈希表。是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。  
举个例子，如果我们有100个苹果，我们要将所有的苹果用24个篮子来装，每个苹果采摘的时间对应的小时数作为分组的依据。  
这24个篮子就相当于我们的散列表，通常来说，散列表越大，就越容易找到数据。但是散列表太大，会增加内存消耗，而且更加容易分得不均匀。  
苹果的采摘时间，就是每个苹果的key，作为唯一标识。  
将对应的时间作为分组的过程就是散列函数，将key里面的小时数转换成篮子编号的过程。  

### 要素1: 关键字

关键字是作为每个数据唯一性的判断，用来查找到指定的存放位置。不同的数据key值是不能一样的。

### 要素2: 散列表

用来存放数据的空间，实现方式通常有数组和链表的方式。  
散列表

### 要素3: 散列函数

散列函数用来将key映射到散列表存放位置的函数，不同的key可能映射到同一个位置。如链表实现散列时，就是映射到链表的表头。也就是说经过散列函数之后得到的位置，我们依然要再去比对key值才能确保数据是我们想要的。  

## hash_demo.c 的例子

假设我们有一组数字，为了能够更快的查询到数据，我们要用hash表的方式来存储数据。  

- key，我们用数字的值来作为关键字
- 散列表，我们用将散列分成100组，这100个桶就是我们的散列表
- 散列函数，将数值求余100，得到桶的编号的过程

## squid里面的hash实现

hash_squid.c, hash_squid.h  

- key，用字符串作为关键字
- 散列表，根据数据量的大小，在hash_primes中选择一个值，算是一种优化
- 散列函数，hash_string()将字符数据转换成桶序号；hash4()将字符串转换成桶序号。两个算法不一样

### squid做的优化

增加扩展性和统计信息的数据，另外做了很多优化，详细可参考代码  

- 每个桶增加了桶中元素个数的计数
- 每个节点增加了对key的比对函数，适应不同类型的key
- 增加了桶大小和当前桶序号的序号，用于遍历hash表做优化。 遍历表时，在每个桶末尾时，自动关联下一个非空桶，跳过了空桶，并封装接口，使使用更方便。
- 增加了元素总数和最大的桶中元素个数计数，用于分析hash表的分布情况
